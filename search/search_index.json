{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Accompanist is a group of libraries that aim to supplement Jetpack Compose with features that are commonly required by developers but not yet available. This version is meant to port some of these libraries to JetBrains Compose, allowing for them to be used on Desktop. Currently, Accompanist Desktop contains: \ud83d\udcd6 Pager \u00b6 A library that provides utilities for building paginated layouts in Jetpack Compose, similar to Android's ViewPager . \u23f3 Placeholder \u00b6 A library that provides easy-to-use modifiers for displaying a placeholder UI while content is loading. \ud83c\udf0a Flow Layouts \u00b6 A library that adds Flexbox-like layout components to Jetpack Compose. \u2b07\ufe0f Swipe to Refresh \u00b6 A library that provides a layout implementing the swipe-to-refresh UX pattern, similar to Android's SwipeRefreshLayout . Updates \u00b6 Jetpack Compose is a fast-moving project and we aim to keep these these libraries up-to-date with the latest tagged release on Compose as quickly as possible. Each release outlines what version of the Compose libraries it depends on. Future? \u00b6 Any of the features available in this group of libraries may become obsolete in the future, at which point they will (probably) become deprecated. We will aim to provide a migration path (where possible), to whatever supersedes the functionality. Snapshots \u00b6 Snapshots of the current development version of Accompanist are available, which track the latest commit. See here for more information. Why the name? \u00b6 The library is all about adding some utilities around Compose. Music composing is done by a composer, and since this library is about supporting composition, the supporting role of an accompanist felt like a good name. Contributions \u00b6 Please contribute! We will gladly review any pull requests. Make sure to read the Contributing page first though. License \u00b6 Copyright 2020 The Android Open Source Project Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at https://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"Overview"},{"location":"#pager","text":"A library that provides utilities for building paginated layouts in Jetpack Compose, similar to Android's ViewPager .","title":"\ud83d\udcd6 Pager"},{"location":"#placeholder","text":"A library that provides easy-to-use modifiers for displaying a placeholder UI while content is loading.","title":"\u23f3 Placeholder"},{"location":"#flow-layouts","text":"A library that adds Flexbox-like layout components to Jetpack Compose.","title":"\ud83c\udf0a Flow Layouts"},{"location":"#swipe-to-refresh","text":"A library that provides a layout implementing the swipe-to-refresh UX pattern, similar to Android's SwipeRefreshLayout .","title":"\u2b07\ufe0f Swipe to Refresh"},{"location":"#updates","text":"Jetpack Compose is a fast-moving project and we aim to keep these these libraries up-to-date with the latest tagged release on Compose as quickly as possible. Each release outlines what version of the Compose libraries it depends on.","title":"Updates"},{"location":"#future","text":"Any of the features available in this group of libraries may become obsolete in the future, at which point they will (probably) become deprecated. We will aim to provide a migration path (where possible), to whatever supersedes the functionality.","title":"Future?"},{"location":"#snapshots","text":"Snapshots of the current development version of Accompanist are available, which track the latest commit. See here for more information.","title":"Snapshots"},{"location":"#why-the-name","text":"The library is all about adding some utilities around Compose. Music composing is done by a composer, and since this library is about supporting composition, the supporting role of an accompanist felt like a good name.","title":"Why the name?"},{"location":"#contributions","text":"Please contribute! We will gladly review any pull requests. Make sure to read the Contributing page first though.","title":"Contributions"},{"location":"#license","text":"Copyright 2020 The Android Open Source Project Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at https://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"License"},{"location":"contributing/","text":"How to Contribute \u00b6 We'd love to accept your patches and contributions to this project. There are just a few small guidelines you need to follow. Contributor License Agreement \u00b6 Contributions to this project must be accompanied by a Contributor License Agreement. You (or your employer) retain the copyright to your contribution, this simply gives us permission to use and redistribute your contributions as part of the project. Head over to https://cla.developers.google.com/ to see your current agreements on file or to sign a new one. You generally only need to submit a CLA once, so if you've already submitted one (even if it was for a different project), you probably don't need to do it again. Code reviews \u00b6 All submissions, including submissions by project members, require review. We use GitHub pull requests for this purpose. Consult GitHub Help for more information on using pull requests.","title":"Contributing"},{"location":"contributing/#how-to-contribute","text":"We'd love to accept your patches and contributions to this project. There are just a few small guidelines you need to follow.","title":"How to Contribute"},{"location":"contributing/#contributor-license-agreement","text":"Contributions to this project must be accompanied by a Contributor License Agreement. You (or your employer) retain the copyright to your contribution, this simply gives us permission to use and redistribute your contributions as part of the project. Head over to https://cla.developers.google.com/ to see your current agreements on file or to sign a new one. You generally only need to submit a CLA once, so if you've already submitted one (even if it was for a different project), you probably don't need to do it again.","title":"Contributor License Agreement"},{"location":"contributing/#code-reviews","text":"All submissions, including submissions by project members, require review. We use GitHub pull requests for this purpose. Consult GitHub Help for more information on using pull requests.","title":"Code reviews"},{"location":"flowlayout/","text":"Jetpack Compose Flow Layouts \u00b6 Flow layouts adapted from the versions which were available in Jetpack Compose until they were removed. Unlike the standard Row and Column composables, these layout children across multiple rows/columns if they exceed the available space. Usage \u00b6 FlowRow { // row contents } FlowColumn { // column contents } For examples, refer to the samples . Download \u00b6 repositories { mavenCentral () } dependencies { implementation ( \"ca.gosyer:accompanist-flowlayout:<version>\" ) } Snapshots of the development version are available in Sonatype's snapshots repository . These are updated on every commit.","title":"Guide"},{"location":"flowlayout/#jetpack-compose-flow-layouts","text":"Flow layouts adapted from the versions which were available in Jetpack Compose until they were removed. Unlike the standard Row and Column composables, these layout children across multiple rows/columns if they exceed the available space.","title":"Jetpack Compose Flow Layouts"},{"location":"flowlayout/#usage","text":"FlowRow { // row contents } FlowColumn { // column contents } For examples, refer to the samples .","title":"Usage"},{"location":"flowlayout/#download","text":"repositories { mavenCentral () } dependencies { implementation ( \"ca.gosyer:accompanist-flowlayout:<version>\" ) } Snapshots of the development version are available in Sonatype's snapshots repository . These are updated on every commit.","title":"Download"},{"location":"pager/","text":"Pager layouts \u00b6 A library which provides paging layouts for Jetpack Compose. If you've used Android's ViewPager before, it has similar properties. Warning The pager layouts are currently experimental and the APIs could change at any time. All of the APIs are marked with the @ExperimentalPagerApi annotation. HorizontalPager \u00b6 HorizontalPager is a layout which lays out items in a horizontal row, and allows the user to horizontally swipe between pages. Your browser does not support the video tag. HorizontalPager demo The simplest usage looks like the following: // Display 10 items val pagerState = rememberPagerState ( pageCount = 10 ) HorizontalPager ( state = pagerState ) { page -> // Our page content Text ( text = \"Page: $ page \" , modifier = Modifier . fillMaxWidth () ) } If you want to jump to a specific page, you either call call pagerState.scrollToPage(index) or pagerState.animateScrollToPage(index) method in a CoroutineScope . VerticalPager \u00b6 VerticalPager is very similar to HorizontalPager but items are laid out vertically, and react to vertical swipes: Your browser does not support the video tag. VerticalPager demo // Display 10 items val pagerState = rememberPagerState ( pageCount = 10 ) VerticalPager ( state = pagerState ) { page -> // Our page content Text ( text = \"Page: $ page \" , modifier = Modifier . fillMaxWidth () ) } Lazy creation \u00b6 Pages in both HorizontalPager and VerticalPager are lazily composed and laid-out as required by the layout. As the user scrolls through pages, any pages which are no longer required are removed from the content. Offscreen Limit \u00b6 The PagerState API allows the setting of the initialOffscreenLimit , which defines the number of pages that should be retained on either side of the current page. Pages beyond this limit will be removed, and then recreated as needed. This value defaults to 1 , but can be increased to enable pre-loading of more content: val pagerState = rememberPagerState ( pageCount = 10 , initialOffscreenLimit = 2 , ) HorizontalPager ( state = pagerState ) { page -> // ... } Item scroll effects \u00b6 A common use-case is to apply effects to your pager items, using the scroll position to drive those effects. The HorizontalPagerTransitionSample demonstrates how this can be done: Your browser does not support the video tag. Item effects demo The scope provided to your pager content allows apps to easily reference the currentPage and currentPageOffset . The effects can then be calculated using those values. We provide the calculateCurrentOffsetForPage() extension functions to support calculation of the 'offset' for a given page: import com.google.accompanist.pager.calculateCurrentOffsetForPage HorizontalPager ( state = pagerState ) { page -> Card ( Modifier . graphicsLayer { // Calculate the absolute offset for the current page from the // scroll position. We use the absolute value which allows us to mirror // any effects for both directions val pageOffset = calculateCurrentOffsetForPage ( page ). absoluteValue // We animate the scaleX + scaleY, between 85% and 100% lerp ( start = 0.85f , stop = 1f , fraction = 1f - pageOffset . coerceIn ( 0f , 1f ) ). also { scale -> scaleX = scale scaleY = scale } // We animate the alpha, between 50% and 100% alpha = lerp ( start = 0.5f , stop = 1f , fraction = 1f - pageOffset . coerceIn ( 0f , 1f ) ) } ) { // Card content } } Reacting to page changes \u00b6 The PagerState.currentPage property is updated whenever the selected page changes. You can use the snapshowFlow function to observe changes in a flow: LaunchedEffect ( pagerState ) { snapshotFlow { pagerState . currentPage }. collect { page -> // Selected page has changed... } } Indicators \u00b6 We also publish a sibling library called pager-indicators which provides some simple indicator composables for use with HorizontalPager and VerticalPager . Your browser does not support the video tag. Pager indicators demo The HorizontalPagerWithIndicatorSample and VerticalPagerWithIndicatorSample show you how to use these. Integration with Tabs \u00b6 A common use-case for HorizontalPager is to be used in conjunction with a TabRow or ScrollableTabRow . Your browser does not support the video tag. HorizontalPager + TabRow Provided in the pager-indicators library is a modifier which can be used on a tab indicator like so: val pagerState = rememberPagerState ( pageCount = pages . size ) TabRow ( // Our selected tab is our current page selectedTabIndex = pagerState . currentPage , // Override the indicator, using the provided pagerTabIndicatorOffset modifier indicator = { tabPositions -> TabRowDefaults . Indicator ( Modifier . pagerTabIndicatorOffset ( pagerState , tabPositions ) ) } ) { // Add tabs for all of our pages pages . forEachIndexed { index , title -> Tab ( text = { Text ( title ) }, selected = pagerState . currentPage == index , onClick = { /* TODO */ }, ) } } HorizontalPager ( state = pagerState ) { page -> // TODO: page content } Usage \u00b6 repositories { mavenCentral () } dependencies { implementation ( \"ca.gosyer:accompanist-pager:<version>\" ) // If using indicators, also depend on implementation ( \"ca.gosyer:accompanist-pager-indicators:<version>\" ) } Library Snapshots \u00b6 Snapshots of the current development version of this library are available, which track the latest commit. See here for more information on how to use them. Contributions \u00b6 Please contribute! We will gladly review any pull requests. Make sure to read the Contributing page first though. License \u00b6 Copyright 2021 The Android Open Source Project Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at https://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"Guide"},{"location":"pager/#pager-layouts","text":"A library which provides paging layouts for Jetpack Compose. If you've used Android's ViewPager before, it has similar properties. Warning The pager layouts are currently experimental and the APIs could change at any time. All of the APIs are marked with the @ExperimentalPagerApi annotation.","title":"Pager layouts"},{"location":"pager/#horizontalpager","text":"HorizontalPager is a layout which lays out items in a horizontal row, and allows the user to horizontally swipe between pages. Your browser does not support the video tag. HorizontalPager demo The simplest usage looks like the following: // Display 10 items val pagerState = rememberPagerState ( pageCount = 10 ) HorizontalPager ( state = pagerState ) { page -> // Our page content Text ( text = \"Page: $ page \" , modifier = Modifier . fillMaxWidth () ) } If you want to jump to a specific page, you either call call pagerState.scrollToPage(index) or pagerState.animateScrollToPage(index) method in a CoroutineScope .","title":"HorizontalPager"},{"location":"pager/#verticalpager","text":"VerticalPager is very similar to HorizontalPager but items are laid out vertically, and react to vertical swipes: Your browser does not support the video tag. VerticalPager demo // Display 10 items val pagerState = rememberPagerState ( pageCount = 10 ) VerticalPager ( state = pagerState ) { page -> // Our page content Text ( text = \"Page: $ page \" , modifier = Modifier . fillMaxWidth () ) }","title":"VerticalPager"},{"location":"pager/#lazy-creation","text":"Pages in both HorizontalPager and VerticalPager are lazily composed and laid-out as required by the layout. As the user scrolls through pages, any pages which are no longer required are removed from the content.","title":"Lazy creation"},{"location":"pager/#offscreen-limit","text":"The PagerState API allows the setting of the initialOffscreenLimit , which defines the number of pages that should be retained on either side of the current page. Pages beyond this limit will be removed, and then recreated as needed. This value defaults to 1 , but can be increased to enable pre-loading of more content: val pagerState = rememberPagerState ( pageCount = 10 , initialOffscreenLimit = 2 , ) HorizontalPager ( state = pagerState ) { page -> // ... }","title":"Offscreen Limit"},{"location":"pager/#item-scroll-effects","text":"A common use-case is to apply effects to your pager items, using the scroll position to drive those effects. The HorizontalPagerTransitionSample demonstrates how this can be done: Your browser does not support the video tag. Item effects demo The scope provided to your pager content allows apps to easily reference the currentPage and currentPageOffset . The effects can then be calculated using those values. We provide the calculateCurrentOffsetForPage() extension functions to support calculation of the 'offset' for a given page: import com.google.accompanist.pager.calculateCurrentOffsetForPage HorizontalPager ( state = pagerState ) { page -> Card ( Modifier . graphicsLayer { // Calculate the absolute offset for the current page from the // scroll position. We use the absolute value which allows us to mirror // any effects for both directions val pageOffset = calculateCurrentOffsetForPage ( page ). absoluteValue // We animate the scaleX + scaleY, between 85% and 100% lerp ( start = 0.85f , stop = 1f , fraction = 1f - pageOffset . coerceIn ( 0f , 1f ) ). also { scale -> scaleX = scale scaleY = scale } // We animate the alpha, between 50% and 100% alpha = lerp ( start = 0.5f , stop = 1f , fraction = 1f - pageOffset . coerceIn ( 0f , 1f ) ) } ) { // Card content } }","title":"Item scroll effects"},{"location":"pager/#reacting-to-page-changes","text":"The PagerState.currentPage property is updated whenever the selected page changes. You can use the snapshowFlow function to observe changes in a flow: LaunchedEffect ( pagerState ) { snapshotFlow { pagerState . currentPage }. collect { page -> // Selected page has changed... } }","title":"Reacting to page changes"},{"location":"pager/#indicators","text":"We also publish a sibling library called pager-indicators which provides some simple indicator composables for use with HorizontalPager and VerticalPager . Your browser does not support the video tag. Pager indicators demo The HorizontalPagerWithIndicatorSample and VerticalPagerWithIndicatorSample show you how to use these.","title":"Indicators"},{"location":"pager/#integration-with-tabs","text":"A common use-case for HorizontalPager is to be used in conjunction with a TabRow or ScrollableTabRow . Your browser does not support the video tag. HorizontalPager + TabRow Provided in the pager-indicators library is a modifier which can be used on a tab indicator like so: val pagerState = rememberPagerState ( pageCount = pages . size ) TabRow ( // Our selected tab is our current page selectedTabIndex = pagerState . currentPage , // Override the indicator, using the provided pagerTabIndicatorOffset modifier indicator = { tabPositions -> TabRowDefaults . Indicator ( Modifier . pagerTabIndicatorOffset ( pagerState , tabPositions ) ) } ) { // Add tabs for all of our pages pages . forEachIndexed { index , title -> Tab ( text = { Text ( title ) }, selected = pagerState . currentPage == index , onClick = { /* TODO */ }, ) } } HorizontalPager ( state = pagerState ) { page -> // TODO: page content }","title":"Integration with Tabs"},{"location":"pager/#usage","text":"repositories { mavenCentral () } dependencies { implementation ( \"ca.gosyer:accompanist-pager:<version>\" ) // If using indicators, also depend on implementation ( \"ca.gosyer:accompanist-pager-indicators:<version>\" ) }","title":"Usage"},{"location":"pager/#library-snapshots","text":"Snapshots of the current development version of this library are available, which track the latest commit. See here for more information on how to use them.","title":"Library Snapshots"},{"location":"pager/#contributions","text":"Please contribute! We will gladly review any pull requests. Make sure to read the Contributing page first though.","title":"Contributions"},{"location":"pager/#license","text":"Copyright 2021 The Android Open Source Project Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at https://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"License"},{"location":"placeholder/","text":"Placeholder \u00b6 A library which provides a modifier for display 'placeholder' UI while content is loading. More information on the UX provided by this library can be found on the Material Theming Placeholder UI guidelines. There are actually two versions of the library available: Placeholder Foundation : Provides the base functionality and depends on Jetpack Compose Foundation. This version requires the app to provide all of the colors to display. Placeholder Material . This uses the foundation library above, but also provides sensible default colors using your app's Material color palette. Tip You only need to use one of the libraries, and most apps should use Placeholder Material . The APIs of the libraries are (mostly) equivalent with only the imports being different. Where possible we have provided equivalent code samples below. Basic usage \u00b6 At the most basic usage, the modifier will draw a shape over your composable content, filled with the provided color. Placeholder Material import com.google.accompanist.placeholder.material.placeholder Text ( text = \"Content to display after content has loaded\" , modifier = Modifier . padding ( 16. dp ) . placeholder ( visible = true ) ) Placeholder Foundation import com.google.accompanist.placeholder.placeholder Text ( text = \"Content to display after content has loaded\" , modifier = Modifier . padding ( 16. dp ) . placeholder ( visible = true , color = Color . Gray , // optional, defaults to RectangleShape shape = RoundedCornerShape ( 4. dp ), ) ) Placeholder highlights \u00b6 The library also provides some 'highlight' animations to entertain the user while they are waiting. There are two provided by the library, but you can also provide your own. Fade \u00b6 This highlight fades a color over the entire placeholder in and out. Your browser does not support the video tag. Placeholder Fade demo Placeholder Material import com.google.accompanist.placeholder.PlaceholderHighlight import com.google.accompanist.placeholder.material.placeholder import com.google.accompanist.placeholder.material.fade Text ( text = \"Content to display after content has loaded\" , modifier = Modifier . padding ( 16. dp ) . placeholder ( visible = true , highlight = PlaceholderHighlight . fade (), ) ) Placeholder Foundation import com.google.accompanist.placeholder.PlaceholderHighlight import com.google.accompanist.placeholder.placeholder import com.google.accompanist.placeholder.fade Text ( text = \"Content to display after content has loaded\" , modifier = Modifier . padding ( 16. dp ) . placeholder ( visible = true , color = Color . Gray , // optional, defaults to RectangleShape shape = RoundedCornerShape ( 4. dp ), highlight = PlaceholderHighlight . fade ( highlightColor = Color . White , ), ) ) Shimmer \u00b6 This displays a gradient shimmer effect which emanates from the top-start corner. Your browser does not support the video tag. Placeholder Shimmer demo Placeholder Material import com.google.accompanist.placeholder.PlaceholderHighlight import com.google.accompanist.placeholder.material.placeholder import com.google.accompanist.placeholder.material.shimmer Text ( text = \"Content to display after content has loaded\" , modifier = Modifier . padding ( 16. dp ) . placeholder ( visible = true , highlight = PlaceholderHighlight . shimmer (), ) ) Placeholder Foundation import com.google.accompanist.placeholder.PlaceholderHighlight import com.google.accompanist.placeholder.placeholder import com.google.accompanist.placeholder.shimmer Text ( text = \"Content to display after content has loaded\" , modifier = Modifier . padding ( 16. dp ) . placeholder ( visible = true , color = Color . Gray , // optional, defaults to RectangleShape shape = RoundedCornerShape ( 4. dp ), highlight = PlaceholderHighlight . shimmer ( highlightColor = Color . White , ), ) ) Usage \u00b6 repositories { mavenCentral () } dependencies { // If you're using Material, use accompanist-placeholder-material implementation ( \"ca.gosyer:accompanist-placeholder-material:<version>\" ) // Otherwise use the foundation version implementation ( \"ca.gosyer:accompanist-placeholder:<version>\" ) } Library Snapshots \u00b6 Snapshots of the current development version of this library are available, which track the latest commit. See here for more information on how to use them. Contributions \u00b6 Please contribute! We will gladly review any pull requests. Make sure to read the Contributing page first though. License \u00b6 Copyright 2021 The Android Open Source Project Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at https://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"Guide"},{"location":"placeholder/#placeholder","text":"A library which provides a modifier for display 'placeholder' UI while content is loading. More information on the UX provided by this library can be found on the Material Theming Placeholder UI guidelines. There are actually two versions of the library available: Placeholder Foundation : Provides the base functionality and depends on Jetpack Compose Foundation. This version requires the app to provide all of the colors to display. Placeholder Material . This uses the foundation library above, but also provides sensible default colors using your app's Material color palette. Tip You only need to use one of the libraries, and most apps should use Placeholder Material . The APIs of the libraries are (mostly) equivalent with only the imports being different. Where possible we have provided equivalent code samples below.","title":"Placeholder"},{"location":"placeholder/#basic-usage","text":"At the most basic usage, the modifier will draw a shape over your composable content, filled with the provided color. Placeholder Material import com.google.accompanist.placeholder.material.placeholder Text ( text = \"Content to display after content has loaded\" , modifier = Modifier . padding ( 16. dp ) . placeholder ( visible = true ) ) Placeholder Foundation import com.google.accompanist.placeholder.placeholder Text ( text = \"Content to display after content has loaded\" , modifier = Modifier . padding ( 16. dp ) . placeholder ( visible = true , color = Color . Gray , // optional, defaults to RectangleShape shape = RoundedCornerShape ( 4. dp ), ) )","title":"Basic usage"},{"location":"placeholder/#placeholder-highlights","text":"The library also provides some 'highlight' animations to entertain the user while they are waiting. There are two provided by the library, but you can also provide your own.","title":"Placeholder highlights"},{"location":"placeholder/#fade","text":"This highlight fades a color over the entire placeholder in and out. Your browser does not support the video tag. Placeholder Fade demo Placeholder Material import com.google.accompanist.placeholder.PlaceholderHighlight import com.google.accompanist.placeholder.material.placeholder import com.google.accompanist.placeholder.material.fade Text ( text = \"Content to display after content has loaded\" , modifier = Modifier . padding ( 16. dp ) . placeholder ( visible = true , highlight = PlaceholderHighlight . fade (), ) ) Placeholder Foundation import com.google.accompanist.placeholder.PlaceholderHighlight import com.google.accompanist.placeholder.placeholder import com.google.accompanist.placeholder.fade Text ( text = \"Content to display after content has loaded\" , modifier = Modifier . padding ( 16. dp ) . placeholder ( visible = true , color = Color . Gray , // optional, defaults to RectangleShape shape = RoundedCornerShape ( 4. dp ), highlight = PlaceholderHighlight . fade ( highlightColor = Color . White , ), ) )","title":"Fade"},{"location":"placeholder/#shimmer","text":"This displays a gradient shimmer effect which emanates from the top-start corner. Your browser does not support the video tag. Placeholder Shimmer demo Placeholder Material import com.google.accompanist.placeholder.PlaceholderHighlight import com.google.accompanist.placeholder.material.placeholder import com.google.accompanist.placeholder.material.shimmer Text ( text = \"Content to display after content has loaded\" , modifier = Modifier . padding ( 16. dp ) . placeholder ( visible = true , highlight = PlaceholderHighlight . shimmer (), ) ) Placeholder Foundation import com.google.accompanist.placeholder.PlaceholderHighlight import com.google.accompanist.placeholder.placeholder import com.google.accompanist.placeholder.shimmer Text ( text = \"Content to display after content has loaded\" , modifier = Modifier . padding ( 16. dp ) . placeholder ( visible = true , color = Color . Gray , // optional, defaults to RectangleShape shape = RoundedCornerShape ( 4. dp ), highlight = PlaceholderHighlight . shimmer ( highlightColor = Color . White , ), ) )","title":"Shimmer"},{"location":"placeholder/#usage","text":"repositories { mavenCentral () } dependencies { // If you're using Material, use accompanist-placeholder-material implementation ( \"ca.gosyer:accompanist-placeholder-material:<version>\" ) // Otherwise use the foundation version implementation ( \"ca.gosyer:accompanist-placeholder:<version>\" ) }","title":"Usage"},{"location":"placeholder/#library-snapshots","text":"Snapshots of the current development version of this library are available, which track the latest commit. See here for more information on how to use them.","title":"Library Snapshots"},{"location":"placeholder/#contributions","text":"Please contribute! We will gladly review any pull requests. Make sure to read the Contributing page first though.","title":"Contributions"},{"location":"placeholder/#license","text":"Copyright 2021 The Android Open Source Project Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at https://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"License"},{"location":"swiperefresh/","text":"Swipe Refresh for Jetpack Compose \u00b6 A library which provides a layout which provides the swipe-to-refresh UX pattern, similar to Android's SwipeRefreshLayout . Your browser does not support the video tag. SwipeRefresh demo Usage \u00b6 To implement this UX pattern there are two key APIs which are needed: SwipeRefresh , which is provides the layout, and rememberSwipeRefreshState() which provides some remembered state. The basic usage of a SwipeRefresh using a ViewModel looks like so: val viewModel : MyViewModel = viewModel () val isRefreshing by viewModel . isRefreshing . collectAsState () SwipeRefresh ( state = rememberSwipeRefreshState ( isRefreshing ), onRefresh = { viewModel . refresh () }, ) { LazyColumn { items ( 30 ) { index -> // TODO: list items } } } The full example, including the view model implementation can be found here . The content needs to be 'scrollable' for SwipeRefresh() to be able to react to swipe gestures. Layouts such as LazyColumn are automatically scrollable, but others such as Column are not. In those instances, you can provide a Modifier.verticalScroll modifier to that content like so: SwipeRefresh ( // ... ) { Column ( Modifier . verticalScroll ( rememberScrollState ())) { // content } } Indicating a refresh without swiping \u00b6 As this library is built with a seperate state object, it's easy to display a refreshing indicator without a swipe to triggering it. The unrealistic example below displays a forever refreshing indicator: val swipeRefreshState = rememberSwipeRefreshState ( true ) SwipeRefresh ( state = swipeRefreshState , onRefresh = { /* todo */ }, ) { LazyColumn { items ( 30 ) { index -> // TODO: list items } } } Indicator \u00b6 The library provides a default indicator: SwipeRefreshIndicator() , which SwipeRefresh uses automatically. You can customize the default indicator, and even provide your own indicator content using the indicator slot. Customizing default indicator \u00b6 To customize the default indicator, we can provide our own indicator content block, to call SwipeRefreshIndicator() with customized parameters: Sample SwipeRefresh ( state = /* ... */ , onRefresh = /* ... */ , indicator = { state , trigger -> SwipeRefreshIndicator ( // Pass the SwipeRefreshState + trigger through state = state , refreshTriggerDistance = trigger , // Enable the scale animation scale = true , // Change the color and shape backgroundColor = MaterialTheme . colors . primary , shape = MaterialTheme . shapes . small , ) } ) Demo video Your browser does not support the video tag. Tweaked indicator demo Custom indicator \u00b6 As mentioned, you can also provide your own custom indicator content. A SwipeRefreshState is provided to indicator content slot, which contains the information necessary to react to a swipe refresh gesture. An example of a custom indicator is provided here . Download \u00b6 repositories { mavenCentral () } dependencies { implementation \"ca.gosyer:accompanist-swiperefresh:<version>\" } Snapshots of the development version are available in Sonatype's snapshots repository . These are updated on every commit.","title":"Guide"},{"location":"swiperefresh/#swipe-refresh-for-jetpack-compose","text":"A library which provides a layout which provides the swipe-to-refresh UX pattern, similar to Android's SwipeRefreshLayout . Your browser does not support the video tag. SwipeRefresh demo","title":"Swipe Refresh for Jetpack Compose"},{"location":"swiperefresh/#usage","text":"To implement this UX pattern there are two key APIs which are needed: SwipeRefresh , which is provides the layout, and rememberSwipeRefreshState() which provides some remembered state. The basic usage of a SwipeRefresh using a ViewModel looks like so: val viewModel : MyViewModel = viewModel () val isRefreshing by viewModel . isRefreshing . collectAsState () SwipeRefresh ( state = rememberSwipeRefreshState ( isRefreshing ), onRefresh = { viewModel . refresh () }, ) { LazyColumn { items ( 30 ) { index -> // TODO: list items } } } The full example, including the view model implementation can be found here . The content needs to be 'scrollable' for SwipeRefresh() to be able to react to swipe gestures. Layouts such as LazyColumn are automatically scrollable, but others such as Column are not. In those instances, you can provide a Modifier.verticalScroll modifier to that content like so: SwipeRefresh ( // ... ) { Column ( Modifier . verticalScroll ( rememberScrollState ())) { // content } }","title":"Usage"},{"location":"swiperefresh/#indicating-a-refresh-without-swiping","text":"As this library is built with a seperate state object, it's easy to display a refreshing indicator without a swipe to triggering it. The unrealistic example below displays a forever refreshing indicator: val swipeRefreshState = rememberSwipeRefreshState ( true ) SwipeRefresh ( state = swipeRefreshState , onRefresh = { /* todo */ }, ) { LazyColumn { items ( 30 ) { index -> // TODO: list items } } }","title":"Indicating a refresh without swiping"},{"location":"swiperefresh/#indicator","text":"The library provides a default indicator: SwipeRefreshIndicator() , which SwipeRefresh uses automatically. You can customize the default indicator, and even provide your own indicator content using the indicator slot.","title":"Indicator"},{"location":"swiperefresh/#customizing-default-indicator","text":"To customize the default indicator, we can provide our own indicator content block, to call SwipeRefreshIndicator() with customized parameters: Sample SwipeRefresh ( state = /* ... */ , onRefresh = /* ... */ , indicator = { state , trigger -> SwipeRefreshIndicator ( // Pass the SwipeRefreshState + trigger through state = state , refreshTriggerDistance = trigger , // Enable the scale animation scale = true , // Change the color and shape backgroundColor = MaterialTheme . colors . primary , shape = MaterialTheme . shapes . small , ) } ) Demo video Your browser does not support the video tag. Tweaked indicator demo","title":"Customizing default indicator"},{"location":"swiperefresh/#custom-indicator","text":"As mentioned, you can also provide your own custom indicator content. A SwipeRefreshState is provided to indicator content slot, which contains the information necessary to react to a swipe refresh gesture. An example of a custom indicator is provided here .","title":"Custom indicator"},{"location":"swiperefresh/#download","text":"repositories { mavenCentral () } dependencies { implementation \"ca.gosyer:accompanist-swiperefresh:<version>\" } Snapshots of the development version are available in Sonatype's snapshots repository . These are updated on every commit.","title":"Download"},{"location":"updating/","text":"Updating & releasing Accompanist \u00b6 This doc is mostly for maintainers. New features & bugfixes \u00b6 All new features should be uploaded as PRs against the main branch. Once merged into main , they will be automatically merged into the snapshot branch. Jetpack Compose Snapshots \u00b6 We publish snapshot versions of Accompanist, which depend on a SNAPSHOT versions of Jetpack Compose. These are built from the snapshot branch. Updating to a newer Compose snapshot \u00b6 As mentioned above, updating to a new Compose snapshot is done by submitting a new PR against the snapshot branch: git checkout snapshot && git pull # Create branch for PR git checkout -b update_snapshot Now edit the project to depend on the new Compose SNAPSHOT version: Edit /gradle/libs.versions.toml : Under [versions] : Update the composesnapshot property to be the snapshot number Ensure that the compose property is correct Make sure the project builds and test pass: ./gradlew check Now git commit the changes and push to GitHub. Finally create a PR (with the base branch as snapshot ) and send for review. Releasing \u00b6 Once the next Jetpack Compose version is out, we're ready to push a new release: #1: Merge snapshot into main \u00b6 First we merge the snapshot branch into main : git checkout snapshot && git pull git checkout main && git pull # Create branch for PR git checkout -b main_snapshot_merge # Merge in the snapshot branch git merge snapshot #2: Update dependencies \u00b6 Edit /gradle/libs.versions.toml : Under [versions] : Update the composesnapshot property to a single character (usually - ). This disables the snapshot repository. Update the compose property to match the new release (i.e. 1.0.0-beta06 ) Make sure the project builds and test pass: ./gradlew check Commit the changes. #3: Bump the version number \u00b6 Edit gradle.properties : Update the VERSION_NAME property and remove the -SNAPSHOT suffix. Commit the changes, using the commit message containing the new version name. #4: Push to GitHub \u00b6 Push the branch to GitHub and create a PR against the main branch, and send for review. Once approved and merged, it will be automatically deployed to Maven Central. #5: Create release \u00b6 Once the above PR has been approved and merged, we need to create the GitHub release: Open up the Releases page. At the top you should see a 'Draft' release, auto populated with any PRs since the last release. Click 'Edit'. Make sure that the version number matches what we released (the tool guesses but is not always correct). Double check everything, then press 'Publish release'. At this point the release is published. This will trigger the docs action to run, which will auto-deploy a new version of the website . #6: Prepare the next development version \u00b6 The current release is now finished, but we need to update the version for the next development version: Edit gradle.properties : Update the VERSION_NAME property, by increasing the version number, and adding the -SNAPSHOT suffix. Example: released version: 0.3.0 . Update to 0.3.1-SNAPSHOT git commit and push to main . Finally, merge all of these changes back to snapshot : git checkout snapshot && git pull git merge main git push","title":"Update guide"},{"location":"updating/#updating-releasing-accompanist","text":"This doc is mostly for maintainers.","title":"Updating &amp; releasing Accompanist"},{"location":"updating/#new-features-bugfixes","text":"All new features should be uploaded as PRs against the main branch. Once merged into main , they will be automatically merged into the snapshot branch.","title":"New features &amp; bugfixes"},{"location":"updating/#jetpack-compose-snapshots","text":"We publish snapshot versions of Accompanist, which depend on a SNAPSHOT versions of Jetpack Compose. These are built from the snapshot branch.","title":"Jetpack Compose Snapshots"},{"location":"updating/#updating-to-a-newer-compose-snapshot","text":"As mentioned above, updating to a new Compose snapshot is done by submitting a new PR against the snapshot branch: git checkout snapshot && git pull # Create branch for PR git checkout -b update_snapshot Now edit the project to depend on the new Compose SNAPSHOT version: Edit /gradle/libs.versions.toml : Under [versions] : Update the composesnapshot property to be the snapshot number Ensure that the compose property is correct Make sure the project builds and test pass: ./gradlew check Now git commit the changes and push to GitHub. Finally create a PR (with the base branch as snapshot ) and send for review.","title":"Updating to a newer Compose snapshot"},{"location":"updating/#releasing","text":"Once the next Jetpack Compose version is out, we're ready to push a new release:","title":"Releasing"},{"location":"updating/#1-merge-snapshot-into-main","text":"First we merge the snapshot branch into main : git checkout snapshot && git pull git checkout main && git pull # Create branch for PR git checkout -b main_snapshot_merge # Merge in the snapshot branch git merge snapshot","title":"#1: Merge snapshot into main"},{"location":"updating/#2-update-dependencies","text":"Edit /gradle/libs.versions.toml : Under [versions] : Update the composesnapshot property to a single character (usually - ). This disables the snapshot repository. Update the compose property to match the new release (i.e. 1.0.0-beta06 ) Make sure the project builds and test pass: ./gradlew check Commit the changes.","title":"#2: Update dependencies"},{"location":"updating/#3-bump-the-version-number","text":"Edit gradle.properties : Update the VERSION_NAME property and remove the -SNAPSHOT suffix. Commit the changes, using the commit message containing the new version name.","title":"#3: Bump the version number"},{"location":"updating/#4-push-to-github","text":"Push the branch to GitHub and create a PR against the main branch, and send for review. Once approved and merged, it will be automatically deployed to Maven Central.","title":"#4: Push to GitHub"},{"location":"updating/#5-create-release","text":"Once the above PR has been approved and merged, we need to create the GitHub release: Open up the Releases page. At the top you should see a 'Draft' release, auto populated with any PRs since the last release. Click 'Edit'. Make sure that the version number matches what we released (the tool guesses but is not always correct). Double check everything, then press 'Publish release'. At this point the release is published. This will trigger the docs action to run, which will auto-deploy a new version of the website .","title":"#5: Create release"},{"location":"updating/#6-prepare-the-next-development-version","text":"The current release is now finished, but we need to update the version for the next development version: Edit gradle.properties : Update the VERSION_NAME property, by increasing the version number, and adding the -SNAPSHOT suffix. Example: released version: 0.3.0 . Update to 0.3.1-SNAPSHOT git commit and push to main . Finally, merge all of these changes back to snapshot : git checkout snapshot && git pull git merge main git push","title":"#6: Prepare the next development version"},{"location":"using-snapshot-version/","text":"Using a Snapshot Version of the Library \u00b6 If you would like to depend on the cutting edge version of the Accompanist library, you can use the snapshot versions that are published to Sonatype OSSRH 's snapshot repository. These are updated on every commit to main . To do so: repositories { // ... maven { url = uri ( \"https://oss.sonatype.org/content/repositories/snapshots\" ) } } dependencies { // Check the latest SNAPSHOT version from the link above implementation ( \"ca.gosyer:accompanist-pager:XXX-SNAPSHOT\" ) }","title":"Snapshots"},{"location":"using-snapshot-version/#using-a-snapshot-version-of-the-library","text":"If you would like to depend on the cutting edge version of the Accompanist library, you can use the snapshot versions that are published to Sonatype OSSRH 's snapshot repository. These are updated on every commit to main . To do so: repositories { // ... maven { url = uri ( \"https://oss.sonatype.org/content/repositories/snapshots\" ) } } dependencies { // Check the latest SNAPSHOT version from the link above implementation ( \"ca.gosyer:accompanist-pager:XXX-SNAPSHOT\" ) }","title":"Using a Snapshot Version of the Library"}]}