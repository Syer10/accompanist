{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Accompanist is a group of libraries that aim to supplement Jetpack Compose with features that are commonly required by developers but not yet available. This version is meant to port some of the Accompanist libraries to Compose Multiplatform, so it can be used on the Jvm and Android. Current Library Compose Multiplatform Version: 1.2.0-alpha01-dev774 Current Library Jetpack Compose Version: 1.2.1 Currently, Accompanist contains: \ud83d\udcd6 Pager \u00b6 A library that provides utilities for building paginated layouts in Jetpack Compose, similar to Android's ViewPager . \u23f3 Placeholder \u00b6 A library that provides easy-to-use modifiers for displaying a placeholder UI while content is loading. \ud83c\udf0a Flow Layouts \u00b6 A library that adds Flexbox-like layout components to Jetpack Compose. \u2b07\ufe0f Swipe to Refresh \u00b6 A library that provides a layout implementing the swipe-to-refresh UX pattern, similar to Android's SwipeRefreshLayout . Future? \u00b6 Any of the features available in this group of libraries may become obsolete in the future, at which point they will (probably) become deprecated. We will aim to provide a migration path (where possible), to whatever supersedes the functionality. Why the name? \u00b6 The library is all about adding some utilities around Compose. Music composing is done by a composer, and since this library is about supporting composition, the supporting role of an accompanist felt like a good name. Contributions \u00b6 Please contribute! We will gladly review any pull requests. Make sure to read the Contributing page first though. License \u00b6 Copyright 2020 The Android Open Source Project Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at https://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"Overview"},{"location":"#pager","text":"A library that provides utilities for building paginated layouts in Jetpack Compose, similar to Android's ViewPager .","title":"\ud83d\udcd6 Pager"},{"location":"#placeholder","text":"A library that provides easy-to-use modifiers for displaying a placeholder UI while content is loading.","title":"\u23f3 Placeholder"},{"location":"#flow-layouts","text":"A library that adds Flexbox-like layout components to Jetpack Compose.","title":"\ud83c\udf0a Flow Layouts"},{"location":"#swipe-to-refresh","text":"A library that provides a layout implementing the swipe-to-refresh UX pattern, similar to Android's SwipeRefreshLayout .","title":"\u2b07\ufe0f Swipe to Refresh"},{"location":"#future","text":"Any of the features available in this group of libraries may become obsolete in the future, at which point they will (probably) become deprecated. We will aim to provide a migration path (where possible), to whatever supersedes the functionality.","title":"Future?"},{"location":"#why-the-name","text":"The library is all about adding some utilities around Compose. Music composing is done by a composer, and since this library is about supporting composition, the supporting role of an accompanist felt like a good name.","title":"Why the name?"},{"location":"#contributions","text":"Please contribute! We will gladly review any pull requests. Make sure to read the Contributing page first though.","title":"Contributions"},{"location":"#license","text":"Copyright 2020 The Android Open Source Project Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at https://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"License"},{"location":"contributing/","text":"How to Contribute \u00b6 We'd love to accept your patches and contributions to this project. There are just a few small guidelines you need to follow. New Features/Libraries \u00b6 Before contributing large new features and/or libraries please start a discussion with us first via GitHub Issues and check that we can support it. We are unable to support all new features, even though we wish we could! If we are unable to support adding your feature, we always encourage you to open source it in your own repository to help the Compose community grow. Contributor License Agreement \u00b6 Contributions to this project must be accompanied by a Contributor License Agreement. You (or your employer) retain the copyright to your contribution, this simply gives us permission to use and redistribute your contributions as part of the project. Head over to https://cla.developers.google.com/ to see your current agreements on file or to sign a new one. You generally only need to submit a CLA once, so if you've already submitted one (even if it was for a different project), you probably don't need to do it again. Code Reviews \u00b6 All submissions, including submissions by project members, require review. We use GitHub pull requests for this purpose. Consult GitHub Help for more information on using pull requests.","title":"Contributing"},{"location":"contributing/#how-to-contribute","text":"We'd love to accept your patches and contributions to this project. There are just a few small guidelines you need to follow.","title":"How to Contribute"},{"location":"contributing/#new-featureslibraries","text":"Before contributing large new features and/or libraries please start a discussion with us first via GitHub Issues and check that we can support it. We are unable to support all new features, even though we wish we could! If we are unable to support adding your feature, we always encourage you to open source it in your own repository to help the Compose community grow.","title":"New Features/Libraries"},{"location":"contributing/#contributor-license-agreement","text":"Contributions to this project must be accompanied by a Contributor License Agreement. You (or your employer) retain the copyright to your contribution, this simply gives us permission to use and redistribute your contributions as part of the project. Head over to https://cla.developers.google.com/ to see your current agreements on file or to sign a new one. You generally only need to submit a CLA once, so if you've already submitted one (even if it was for a different project), you probably don't need to do it again.","title":"Contributor License Agreement"},{"location":"contributing/#code-reviews","text":"All submissions, including submissions by project members, require review. We use GitHub pull requests for this purpose. Consult GitHub Help for more information on using pull requests.","title":"Code Reviews"},{"location":"flowlayout/","text":"Jetpack Compose Flow Layouts \u00b6 Flow layouts adapted from the versions which were available in Jetpack Compose until they were removed. Unlike the standard Row and Column composables, these layout children across multiple rows/columns if they exceed the available space. Usage \u00b6 FlowRow { // row contents } FlowColumn { // column contents } For examples, refer to the samples . Download \u00b6 repositories { mavenCentral () } dependencies { implementation \"com.google.accompanist:accompanist-flowlayout:<version>\" } Snapshots of the development version are available in Sonatype's snapshots repository . These are updated on every commit.","title":"Guide"},{"location":"flowlayout/#jetpack-compose-flow-layouts","text":"Flow layouts adapted from the versions which were available in Jetpack Compose until they were removed. Unlike the standard Row and Column composables, these layout children across multiple rows/columns if they exceed the available space.","title":"Jetpack Compose Flow Layouts"},{"location":"flowlayout/#usage","text":"FlowRow { // row contents } FlowColumn { // column contents } For examples, refer to the samples .","title":"Usage"},{"location":"flowlayout/#download","text":"repositories { mavenCentral () } dependencies { implementation \"com.google.accompanist:accompanist-flowlayout:<version>\" } Snapshots of the development version are available in Sonatype's snapshots repository . These are updated on every commit.","title":"Download"},{"location":"migration/","text":"Migration from dev.chrisbanes.accompanist \u00b6 In March 2021, the Accompanist project moved from github.com/chrisbanes/accompanist to github.com/google/accompanist . At the same time we migrated the libraries over to a new package name and Maven group ID. As a summary: All code was refactored from the dev.chrisbanes.accompanist root package to com.google.accompanist package. The Maven group ID was changed from dev.chrisbanes.accompanist to com.google.accompanist . Semi-automatic migration... \u00b6 The following methods below are available for your information only, but may help if you need to migrate from the old package name. Warning Use these at your own risk, but they have worked on multiple projects from my testing. It's a good idea to make sure that you've made a backup or committed any changes before running these. Android Studio / IntelliJ \u00b6 You can use the Replace in Path pane (\u21e7\u2318R on Mac) in Android Studio to do a project-wide search and replace. Find query: dev.chrisbanes.accompanist Replace string: com.google.accompanist Optional: Set the file mask to *.kt so that only Kotlin files are searched. Repeat for *.gradle . Similar can be achieved in Visual Studio Code . Other IDEs / text editors are available. YOLO commands \u00b6 These commands while automatically replace any imports and Gradle dependencies for the project in the current directory. MacOS \u00b6 find . -type f \\( -name '*.kt' -or -name '*.gradle*' \\) \\ -exec sed -i '' 's/dev\\.chrisbanes\\.accompanist/com\\.google\\.accompanist/' {} \\; Linux \u00b6 find . -type f \\( -name '*.kt' -or -name '*.gradle*' \\) \\ -exec sed -i 's/dev\\.chrisbanes\\.accompanist/com\\.google\\.accompanist/' {} \\;","title":"Migration from dev.chrisbanes.accompanist"},{"location":"migration/#migration-from-devchrisbanesaccompanist","text":"In March 2021, the Accompanist project moved from github.com/chrisbanes/accompanist to github.com/google/accompanist . At the same time we migrated the libraries over to a new package name and Maven group ID. As a summary: All code was refactored from the dev.chrisbanes.accompanist root package to com.google.accompanist package. The Maven group ID was changed from dev.chrisbanes.accompanist to com.google.accompanist .","title":"Migration from dev.chrisbanes.accompanist"},{"location":"migration/#semi-automatic-migration","text":"The following methods below are available for your information only, but may help if you need to migrate from the old package name. Warning Use these at your own risk, but they have worked on multiple projects from my testing. It's a good idea to make sure that you've made a backup or committed any changes before running these.","title":"Semi-automatic migration..."},{"location":"migration/#android-studio-intellij","text":"You can use the Replace in Path pane (\u21e7\u2318R on Mac) in Android Studio to do a project-wide search and replace. Find query: dev.chrisbanes.accompanist Replace string: com.google.accompanist Optional: Set the file mask to *.kt so that only Kotlin files are searched. Repeat for *.gradle . Similar can be achieved in Visual Studio Code . Other IDEs / text editors are available.","title":"Android Studio / IntelliJ"},{"location":"migration/#yolo-commands","text":"These commands while automatically replace any imports and Gradle dependencies for the project in the current directory.","title":"YOLO commands"},{"location":"migration/#macos","text":"find . -type f \\( -name '*.kt' -or -name '*.gradle*' \\) \\ -exec sed -i '' 's/dev\\.chrisbanes\\.accompanist/com\\.google\\.accompanist/' {} \\;","title":"MacOS"},{"location":"migration/#linux","text":"find . -type f \\( -name '*.kt' -or -name '*.gradle*' \\) \\ -exec sed -i 's/dev\\.chrisbanes\\.accompanist/com\\.google\\.accompanist/' {} \\;","title":"Linux"},{"location":"pager/","text":"Pager layouts \u00b6 A library which provides paging layouts for Jetpack Compose. If you've used Android's ViewPager before, it has similar properties. Warning The pager layouts are currently experimental and the APIs could change at any time. All of the APIs are marked with the @ExperimentalPagerApi annotation. HorizontalPager \u00b6 HorizontalPager is a layout which lays out items in a horizontal row, and allows the user to horizontally swipe between pages. Your browser does not support the video tag. HorizontalPager demo The simplest usage looks like the following: // Display 10 items HorizontalPager ( count = 10 ) { page -> // Our page content Text ( text = \"Page: $ page \" , modifier = Modifier . fillMaxWidth () ) } If you want to jump to a specific page, you either call call pagerState.scrollToPage(index) or pagerState.animateScrollToPage(index) method in a CoroutineScope . val pagerState = rememberPagerState () HorizontalPager ( count = 10 , state = pagerState ) { page -> // ...page content } // Later, scroll to page 2 scope . launch { pagerState . scrollToPage ( 2 ) } VerticalPager \u00b6 VerticalPager is very similar to HorizontalPager but items are laid out vertically, and react to vertical swipes: Your browser does not support the video tag. VerticalPager demo // Display 10 items VerticalPager ( count = 10 ) { page -> // Our page content Text ( text = \"Page: $ page \" , modifier = Modifier . fillMaxWidth () ) } Lazy creation \u00b6 Pages in both HorizontalPager and VerticalPager are lazily composed and laid-out as required by the layout. As the user scrolls through pages, any pages which are no longer required are removed from the content. Under the covers, HorizontalPager use LazyRow , and VerticalPager uses LazyColumn . Content Padding \u00b6 HorizontalPager and VerticalPager both support the setting of content padding, which allows you to influence the maximum size and alignment of pages. You can see how different content padding values affect a HorizontalPager below: start = 64.dp Setting the start padding has the effect of aligning the pages towards the end. HorizontalPager ( count = 4 , contentPadding = PaddingValues ( start = 64. dp ), ) { page -> // page content } horizontal = 32.dp Setting both the start and end padding to the same value has the effect of centering the item horizontally. HorizontalPager ( count = 4 , contentPadding = PaddingValues ( horizontal = 32. dp ), ) { page -> // page content } end = 64.dp Setting the end padding has the effect of aligning the pages towards the start. HorizontalPager ( count = 4 , contentPadding = PaddingValues ( end = 64. dp ), ) { page -> // page content } Similar effects for VerticalPager can be achieved by setting the top and bottom values. The value 32.dp is only used here as an example, you can set each of the padding dimensions to whatever value you wish. Item scroll effects \u00b6 A common use-case is to apply effects to your pager items, using the scroll position to drive those effects. The HorizontalPagerTransitionSample demonstrates how this can be done: Your browser does not support the video tag. Item effects demo The scope provided to your pager content allows apps to easily reference the currentPage and currentPageOffset . The effects can then be calculated using those values. We provide the calculateCurrentOffsetForPage() extension functions to support calculation of the 'offset' for a given page: import com.google.accompanist.pager.calculateCurrentOffsetForPage HorizontalPager ( count = 4 ) { page -> Card ( Modifier . graphicsLayer { // Calculate the absolute offset for the current page from the // scroll position. We use the absolute value which allows us to mirror // any effects for both directions val pageOffset = calculateCurrentOffsetForPage ( page ). absoluteValue // We animate the scaleX + scaleY, between 85% and 100% lerp ( start = 0.85f , stop = 1f , fraction = 1f - pageOffset . coerceIn ( 0f , 1f ) ). also { scale -> scaleX = scale scaleY = scale } // We animate the alpha, between 50% and 100% alpha = lerp ( start = 0.5f , stop = 1f , fraction = 1f - pageOffset . coerceIn ( 0f , 1f ) ) } ) { // Card content } } Reacting to page changes \u00b6 The PagerState.currentPage property is updated whenever the selected page changes. You can use the snapshotFlow function to observe changes in a flow: val pagerState = rememberPagerState () LaunchedEffect ( pagerState ) { // Collect from the pager state a snapshotFlow reading the currentPage snapshotFlow { pagerState . currentPage }. collect { page -> AnalyticsService . sendPageSelectedEvent ( page ) } } VerticalPager ( count = 10 , state = pagerState , ) { page -> Text ( text = \"Page: $ page \" ) } Indicators \u00b6 We also publish a sibling library called pager-indicators which provides some simple indicator composables for use with HorizontalPager and VerticalPager . Your browser does not support the video tag. Pager indicators demo The HorizontalPagerWithIndicatorSample and VerticalPagerWithIndicatorSample show you how to use these. Integration with Tabs \u00b6 A common use-case for HorizontalPager is to be used in conjunction with a TabRow or ScrollableTabRow . Your browser does not support the video tag. HorizontalPager + TabRow Provided in the pager-indicators library is a modifier which can be used on a tab indicator like so: val pagerState = rememberPagerState () TabRow ( // Our selected tab is our current page selectedTabIndex = pagerState . currentPage , // Override the indicator, using the provided pagerTabIndicatorOffset modifier indicator = { tabPositions -> TabRowDefaults . Indicator ( Modifier . pagerTabIndicatorOffset ( pagerState , tabPositions ) ) } ) { // Add tabs for all of our pages pages . forEachIndexed { index , title -> Tab ( text = { Text ( title ) }, selected = pagerState . currentPage == index , onClick = { /* TODO */ }, ) } } HorizontalPager ( count = pages . size , state = pagerState , ) { page -> // TODO: page content } Changes in v0.19.0 \u00b6 In v0.19.0 both HorizontalPager and VerticalPager were re-written to be based on LazyRow and LazyColumn respectively. As part of this change, a number of feature and API changes were made: PagerState \u00b6 The pageCount parameter on rememberPagerState() has been removed, replaced with the count parameter on HorizontalPager() and VerticalPager() . The animationSpec , initialVelocity and skipPages parameters on animateScrollToPage() have been removed. The lazy components handle this automatically. HorizontalPager & VerticalPager \u00b6 Ability to set contentPadding (see above ). Ability to specify a key for each page. The horizontalAlignment parameter on HorizontalPager , and the verticalAlignment parameter on VerticalPager have been removed. A similar effect can be implemented with an appropriate content padding (see above ). The infiniteLooping parameter and feature have been removed. A sample demonstrating how to achieve this effect can be found here . The offscreenLimit parameter has been removed. We no longer have control of what items are laid out 'off screen'. The dragEnabled parameter has removed. PagerScope (the page item scope) no longer implements BoxScope . Usage \u00b6 repositories { mavenCentral () } dependencies { implementation \"com.google.accompanist:accompanist-pager:<version>\" // If using indicators, also depend on implementation \"com.google.accompanist:accompanist-pager-indicators:<version>\" } Library Snapshots \u00b6 Snapshots of the current development version of this library are available, which track the latest commit. See here for more information on how to use them. Contributions \u00b6 Please contribute! We will gladly review any pull requests. Make sure to read the Contributing page first though. License \u00b6 Copyright 2021 The Android Open Source Project Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at https://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"Guide"},{"location":"pager/#pager-layouts","text":"A library which provides paging layouts for Jetpack Compose. If you've used Android's ViewPager before, it has similar properties. Warning The pager layouts are currently experimental and the APIs could change at any time. All of the APIs are marked with the @ExperimentalPagerApi annotation.","title":"Pager layouts"},{"location":"pager/#horizontalpager","text":"HorizontalPager is a layout which lays out items in a horizontal row, and allows the user to horizontally swipe between pages. Your browser does not support the video tag. HorizontalPager demo The simplest usage looks like the following: // Display 10 items HorizontalPager ( count = 10 ) { page -> // Our page content Text ( text = \"Page: $ page \" , modifier = Modifier . fillMaxWidth () ) } If you want to jump to a specific page, you either call call pagerState.scrollToPage(index) or pagerState.animateScrollToPage(index) method in a CoroutineScope . val pagerState = rememberPagerState () HorizontalPager ( count = 10 , state = pagerState ) { page -> // ...page content } // Later, scroll to page 2 scope . launch { pagerState . scrollToPage ( 2 ) }","title":"HorizontalPager"},{"location":"pager/#verticalpager","text":"VerticalPager is very similar to HorizontalPager but items are laid out vertically, and react to vertical swipes: Your browser does not support the video tag. VerticalPager demo // Display 10 items VerticalPager ( count = 10 ) { page -> // Our page content Text ( text = \"Page: $ page \" , modifier = Modifier . fillMaxWidth () ) }","title":"VerticalPager"},{"location":"pager/#lazy-creation","text":"Pages in both HorizontalPager and VerticalPager are lazily composed and laid-out as required by the layout. As the user scrolls through pages, any pages which are no longer required are removed from the content. Under the covers, HorizontalPager use LazyRow , and VerticalPager uses LazyColumn .","title":"Lazy creation"},{"location":"pager/#content-padding","text":"HorizontalPager and VerticalPager both support the setting of content padding, which allows you to influence the maximum size and alignment of pages. You can see how different content padding values affect a HorizontalPager below: start = 64.dp Setting the start padding has the effect of aligning the pages towards the end. HorizontalPager ( count = 4 , contentPadding = PaddingValues ( start = 64. dp ), ) { page -> // page content } horizontal = 32.dp Setting both the start and end padding to the same value has the effect of centering the item horizontally. HorizontalPager ( count = 4 , contentPadding = PaddingValues ( horizontal = 32. dp ), ) { page -> // page content } end = 64.dp Setting the end padding has the effect of aligning the pages towards the start. HorizontalPager ( count = 4 , contentPadding = PaddingValues ( end = 64. dp ), ) { page -> // page content } Similar effects for VerticalPager can be achieved by setting the top and bottom values. The value 32.dp is only used here as an example, you can set each of the padding dimensions to whatever value you wish.","title":"Content Padding"},{"location":"pager/#item-scroll-effects","text":"A common use-case is to apply effects to your pager items, using the scroll position to drive those effects. The HorizontalPagerTransitionSample demonstrates how this can be done: Your browser does not support the video tag. Item effects demo The scope provided to your pager content allows apps to easily reference the currentPage and currentPageOffset . The effects can then be calculated using those values. We provide the calculateCurrentOffsetForPage() extension functions to support calculation of the 'offset' for a given page: import com.google.accompanist.pager.calculateCurrentOffsetForPage HorizontalPager ( count = 4 ) { page -> Card ( Modifier . graphicsLayer { // Calculate the absolute offset for the current page from the // scroll position. We use the absolute value which allows us to mirror // any effects for both directions val pageOffset = calculateCurrentOffsetForPage ( page ). absoluteValue // We animate the scaleX + scaleY, between 85% and 100% lerp ( start = 0.85f , stop = 1f , fraction = 1f - pageOffset . coerceIn ( 0f , 1f ) ). also { scale -> scaleX = scale scaleY = scale } // We animate the alpha, between 50% and 100% alpha = lerp ( start = 0.5f , stop = 1f , fraction = 1f - pageOffset . coerceIn ( 0f , 1f ) ) } ) { // Card content } }","title":"Item scroll effects"},{"location":"pager/#reacting-to-page-changes","text":"The PagerState.currentPage property is updated whenever the selected page changes. You can use the snapshotFlow function to observe changes in a flow: val pagerState = rememberPagerState () LaunchedEffect ( pagerState ) { // Collect from the pager state a snapshotFlow reading the currentPage snapshotFlow { pagerState . currentPage }. collect { page -> AnalyticsService . sendPageSelectedEvent ( page ) } } VerticalPager ( count = 10 , state = pagerState , ) { page -> Text ( text = \"Page: $ page \" ) }","title":"Reacting to page changes"},{"location":"pager/#indicators","text":"We also publish a sibling library called pager-indicators which provides some simple indicator composables for use with HorizontalPager and VerticalPager . Your browser does not support the video tag. Pager indicators demo The HorizontalPagerWithIndicatorSample and VerticalPagerWithIndicatorSample show you how to use these.","title":"Indicators"},{"location":"pager/#integration-with-tabs","text":"A common use-case for HorizontalPager is to be used in conjunction with a TabRow or ScrollableTabRow . Your browser does not support the video tag. HorizontalPager + TabRow Provided in the pager-indicators library is a modifier which can be used on a tab indicator like so: val pagerState = rememberPagerState () TabRow ( // Our selected tab is our current page selectedTabIndex = pagerState . currentPage , // Override the indicator, using the provided pagerTabIndicatorOffset modifier indicator = { tabPositions -> TabRowDefaults . Indicator ( Modifier . pagerTabIndicatorOffset ( pagerState , tabPositions ) ) } ) { // Add tabs for all of our pages pages . forEachIndexed { index , title -> Tab ( text = { Text ( title ) }, selected = pagerState . currentPage == index , onClick = { /* TODO */ }, ) } } HorizontalPager ( count = pages . size , state = pagerState , ) { page -> // TODO: page content }","title":"Integration with Tabs"},{"location":"pager/#changes-in-v0190","text":"In v0.19.0 both HorizontalPager and VerticalPager were re-written to be based on LazyRow and LazyColumn respectively. As part of this change, a number of feature and API changes were made:","title":"Changes in v0.19.0"},{"location":"pager/#pagerstate","text":"The pageCount parameter on rememberPagerState() has been removed, replaced with the count parameter on HorizontalPager() and VerticalPager() . The animationSpec , initialVelocity and skipPages parameters on animateScrollToPage() have been removed. The lazy components handle this automatically.","title":"PagerState"},{"location":"pager/#horizontalpager-verticalpager","text":"Ability to set contentPadding (see above ). Ability to specify a key for each page. The horizontalAlignment parameter on HorizontalPager , and the verticalAlignment parameter on VerticalPager have been removed. A similar effect can be implemented with an appropriate content padding (see above ). The infiniteLooping parameter and feature have been removed. A sample demonstrating how to achieve this effect can be found here . The offscreenLimit parameter has been removed. We no longer have control of what items are laid out 'off screen'. The dragEnabled parameter has removed. PagerScope (the page item scope) no longer implements BoxScope .","title":"HorizontalPager &amp; VerticalPager"},{"location":"pager/#usage","text":"repositories { mavenCentral () } dependencies { implementation \"com.google.accompanist:accompanist-pager:<version>\" // If using indicators, also depend on implementation \"com.google.accompanist:accompanist-pager-indicators:<version>\" }","title":"Usage"},{"location":"pager/#library-snapshots","text":"Snapshots of the current development version of this library are available, which track the latest commit. See here for more information on how to use them.","title":"Library Snapshots"},{"location":"pager/#contributions","text":"Please contribute! We will gladly review any pull requests. Make sure to read the Contributing page first though.","title":"Contributions"},{"location":"pager/#license","text":"Copyright 2021 The Android Open Source Project Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at https://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"License"},{"location":"swiperefresh/","text":"Swipe Refresh for Jetpack Compose \u00b6 A library which provides a layout which provides the swipe-to-refresh UX pattern, similar to Android's SwipeRefreshLayout . Your browser does not support the video tag. SwipeRefresh demo Usage \u00b6 To implement this UX pattern there are two key APIs which are needed: SwipeRefresh , which is provides the layout, and rememberSwipeRefreshState() which provides some remembered state. The basic usage of a SwipeRefresh using a ViewModel looks like so: val viewModel : MyViewModel = viewModel () val isRefreshing by viewModel . isRefreshing . collectAsState () SwipeRefresh ( state = rememberSwipeRefreshState ( isRefreshing ), onRefresh = { viewModel . refresh () }, ) { LazyColumn { items ( 30 ) { index -> // TODO: list items } } } The full example, including the view model implementation can be found here . The content needs to be 'vertically scrollable' for SwipeRefresh() to be able to react to swipe gestures. Layouts such as LazyColumn are automatically vertically scrollable, but others such as Column or LazyRow are not. In those instances, you can provide a Modifier.verticalScroll modifier to that content like so: SwipeRefresh ( // ... ) { Column ( Modifier . verticalScroll ( rememberScrollState ())) { // content } } Indicating a refresh without swiping \u00b6 As this library is built with a separate state object, it's easy to display a refreshing indicator without a swipe to triggering it. The unrealistic example below displays a forever refreshing indicator: val swipeRefreshState = rememberSwipeRefreshState ( true ) SwipeRefresh ( state = swipeRefreshState , onRefresh = { /* todo */ }, ) { LazyColumn { items ( 30 ) { index -> // TODO: list items } } } Indicator \u00b6 The library provides a default indicator: SwipeRefreshIndicator() , which SwipeRefresh uses automatically. You can customize the default indicator, and even provide your own indicator content using the indicator slot. Customizing default indicator \u00b6 To customize the default indicator, we can provide our own indicator content block, to call SwipeRefreshIndicator() with customized parameters: Sample SwipeRefresh ( state = /* ... */ , onRefresh = /* ... */ , indicator = { state , trigger -> SwipeRefreshIndicator ( // Pass the SwipeRefreshState + trigger through state = state , refreshTriggerDistance = trigger , // Enable the scale animation scale = true , // Change the color and shape backgroundColor = MaterialTheme . colors . primary , shape = MaterialTheme . shapes . small , ) } ) Demo video Your browser does not support the video tag. Tweaked indicator demo Custom indicator \u00b6 As mentioned, you can also provide your own custom indicator content. A SwipeRefreshState is provided to indicator content slot, which contains the information necessary to react to a swipe refresh gesture. An example of a custom indicator is provided here . Download \u00b6 repositories { mavenCentral () } dependencies { implementation \"com.google.accompanist:accompanist-swiperefresh:<version>\" } Snapshots of the development version are available in Sonatype's snapshots repository . These are updated on every commit.","title":"Guide"},{"location":"swiperefresh/#swipe-refresh-for-jetpack-compose","text":"A library which provides a layout which provides the swipe-to-refresh UX pattern, similar to Android's SwipeRefreshLayout . Your browser does not support the video tag. SwipeRefresh demo","title":"Swipe Refresh for Jetpack Compose"},{"location":"swiperefresh/#usage","text":"To implement this UX pattern there are two key APIs which are needed: SwipeRefresh , which is provides the layout, and rememberSwipeRefreshState() which provides some remembered state. The basic usage of a SwipeRefresh using a ViewModel looks like so: val viewModel : MyViewModel = viewModel () val isRefreshing by viewModel . isRefreshing . collectAsState () SwipeRefresh ( state = rememberSwipeRefreshState ( isRefreshing ), onRefresh = { viewModel . refresh () }, ) { LazyColumn { items ( 30 ) { index -> // TODO: list items } } } The full example, including the view model implementation can be found here . The content needs to be 'vertically scrollable' for SwipeRefresh() to be able to react to swipe gestures. Layouts such as LazyColumn are automatically vertically scrollable, but others such as Column or LazyRow are not. In those instances, you can provide a Modifier.verticalScroll modifier to that content like so: SwipeRefresh ( // ... ) { Column ( Modifier . verticalScroll ( rememberScrollState ())) { // content } }","title":"Usage"},{"location":"swiperefresh/#indicating-a-refresh-without-swiping","text":"As this library is built with a separate state object, it's easy to display a refreshing indicator without a swipe to triggering it. The unrealistic example below displays a forever refreshing indicator: val swipeRefreshState = rememberSwipeRefreshState ( true ) SwipeRefresh ( state = swipeRefreshState , onRefresh = { /* todo */ }, ) { LazyColumn { items ( 30 ) { index -> // TODO: list items } } }","title":"Indicating a refresh without swiping"},{"location":"swiperefresh/#indicator","text":"The library provides a default indicator: SwipeRefreshIndicator() , which SwipeRefresh uses automatically. You can customize the default indicator, and even provide your own indicator content using the indicator slot.","title":"Indicator"},{"location":"swiperefresh/#customizing-default-indicator","text":"To customize the default indicator, we can provide our own indicator content block, to call SwipeRefreshIndicator() with customized parameters: Sample SwipeRefresh ( state = /* ... */ , onRefresh = /* ... */ , indicator = { state , trigger -> SwipeRefreshIndicator ( // Pass the SwipeRefreshState + trigger through state = state , refreshTriggerDistance = trigger , // Enable the scale animation scale = true , // Change the color and shape backgroundColor = MaterialTheme . colors . primary , shape = MaterialTheme . shapes . small , ) } ) Demo video Your browser does not support the video tag. Tweaked indicator demo","title":"Customizing default indicator"},{"location":"swiperefresh/#custom-indicator","text":"As mentioned, you can also provide your own custom indicator content. A SwipeRefreshState is provided to indicator content slot, which contains the information necessary to react to a swipe refresh gesture. An example of a custom indicator is provided here .","title":"Custom indicator"},{"location":"swiperefresh/#download","text":"repositories { mavenCentral () } dependencies { implementation \"com.google.accompanist:accompanist-swiperefresh:<version>\" } Snapshots of the development version are available in Sonatype's snapshots repository . These are updated on every commit.","title":"Download"},{"location":"updating/","text":"Updating & releasing Accompanist \u00b6 This doc is mostly for maintainers. New features & bugfixes \u00b6 All new features should be uploaded as PRs against the main branch. Once merged into main , they will be automatically merged into the snapshot branch. Jetpack Compose Snapshots \u00b6 We publish snapshot versions of Accompanist, which depend on a SNAPSHOT versions of Jetpack Compose. These are built from the snapshot branch. Updating to a newer Compose snapshot \u00b6 As mentioned above, updating to a new Compose snapshot is done by submitting a new PR against the snapshot branch: git checkout snapshot && git pull # Create branch for PR git checkout -b update_snapshot Now edit the project to depend on the new Compose SNAPSHOT version: Edit /gradle/libs.versions.toml : Under [versions] : Update the composesnapshot property to be the snapshot number Ensure that the compose property is correct Make sure the project builds and test pass: ./gradlew check Now git commit the changes and push to GitHub. Finally create a PR (with the base branch as snapshot ) and send for review. Releasing \u00b6 Once the next Jetpack Compose version is out, we're ready to push a new release: #1: Merge snapshot into main \u00b6 First we merge the snapshot branch into main : git checkout snapshot && git pull git checkout main && git pull # Create branch for PR git checkout -b main_snapshot_merge # Merge in the snapshot branch git merge snapshot #2: Update dependencies \u00b6 Edit /gradle/libs.versions.toml : Under [versions] : Update the composesnapshot property to a single character (usually - ). This disables the snapshot repository. Update the compose property to match the new release (i.e. 1.0.0-beta06 ) Make sure the project builds and test pass: ./gradlew check Commit the changes. #3: Bump the version number \u00b6 Edit gradle.properties : Update the VERSION_NAME property and remove the -SNAPSHOT suffix. Commit the changes, using the commit message containing the new version name. #4: Push to GitHub \u00b6 Push the branch to GitHub and create a PR against the main branch, and send for review. Once approved and merged, it will be automatically deployed to Maven Central. #5: Create release \u00b6 Once the above PR has been approved and merged, we need to create the GitHub release: Open up the Releases page. At the top you should see a 'Draft' release, auto populated with any PRs since the last release. Click 'Edit'. Make sure that the version number matches what we released (the tool guesses but is not always correct). Double check everything, then press 'Publish release'. At this point the release is published. This will trigger the docs action to run, which will auto-deploy a new version of the website . #6: Prepare the next development version \u00b6 The current release is now finished, but we need to update the version for the next development version: Edit gradle.properties : Update the VERSION_NAME property, by increasing the version number, and adding the -SNAPSHOT suffix. Example: released version: 0.3.0 . Update to 0.3.1-SNAPSHOT git commit and push to main . Finally, merge all of these changes back to snapshot : git checkout snapshot && git pull git merge main git push","title":"Update guide"},{"location":"updating/#updating-releasing-accompanist","text":"This doc is mostly for maintainers.","title":"Updating &amp; releasing Accompanist"},{"location":"updating/#new-features-bugfixes","text":"All new features should be uploaded as PRs against the main branch. Once merged into main , they will be automatically merged into the snapshot branch.","title":"New features &amp; bugfixes"},{"location":"updating/#jetpack-compose-snapshots","text":"We publish snapshot versions of Accompanist, which depend on a SNAPSHOT versions of Jetpack Compose. These are built from the snapshot branch.","title":"Jetpack Compose Snapshots"},{"location":"updating/#updating-to-a-newer-compose-snapshot","text":"As mentioned above, updating to a new Compose snapshot is done by submitting a new PR against the snapshot branch: git checkout snapshot && git pull # Create branch for PR git checkout -b update_snapshot Now edit the project to depend on the new Compose SNAPSHOT version: Edit /gradle/libs.versions.toml : Under [versions] : Update the composesnapshot property to be the snapshot number Ensure that the compose property is correct Make sure the project builds and test pass: ./gradlew check Now git commit the changes and push to GitHub. Finally create a PR (with the base branch as snapshot ) and send for review.","title":"Updating to a newer Compose snapshot"},{"location":"updating/#releasing","text":"Once the next Jetpack Compose version is out, we're ready to push a new release:","title":"Releasing"},{"location":"updating/#1-merge-snapshot-into-main","text":"First we merge the snapshot branch into main : git checkout snapshot && git pull git checkout main && git pull # Create branch for PR git checkout -b main_snapshot_merge # Merge in the snapshot branch git merge snapshot","title":"#1: Merge snapshot into main"},{"location":"updating/#2-update-dependencies","text":"Edit /gradle/libs.versions.toml : Under [versions] : Update the composesnapshot property to a single character (usually - ). This disables the snapshot repository. Update the compose property to match the new release (i.e. 1.0.0-beta06 ) Make sure the project builds and test pass: ./gradlew check Commit the changes.","title":"#2: Update dependencies"},{"location":"updating/#3-bump-the-version-number","text":"Edit gradle.properties : Update the VERSION_NAME property and remove the -SNAPSHOT suffix. Commit the changes, using the commit message containing the new version name.","title":"#3: Bump the version number"},{"location":"updating/#4-push-to-github","text":"Push the branch to GitHub and create a PR against the main branch, and send for review. Once approved and merged, it will be automatically deployed to Maven Central.","title":"#4: Push to GitHub"},{"location":"updating/#5-create-release","text":"Once the above PR has been approved and merged, we need to create the GitHub release: Open up the Releases page. At the top you should see a 'Draft' release, auto populated with any PRs since the last release. Click 'Edit'. Make sure that the version number matches what we released (the tool guesses but is not always correct). Double check everything, then press 'Publish release'. At this point the release is published. This will trigger the docs action to run, which will auto-deploy a new version of the website .","title":"#5: Create release"},{"location":"updating/#6-prepare-the-next-development-version","text":"The current release is now finished, but we need to update the version for the next development version: Edit gradle.properties : Update the VERSION_NAME property, by increasing the version number, and adding the -SNAPSHOT suffix. Example: released version: 0.3.0 . Update to 0.3.1-SNAPSHOT git commit and push to main . Finally, merge all of these changes back to snapshot : git checkout snapshot && git pull git merge main git push","title":"#6: Prepare the next development version"}]}